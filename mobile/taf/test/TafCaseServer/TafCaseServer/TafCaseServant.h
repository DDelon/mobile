// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 1.5.7 by WSRD Tencent.
// Generated from `TafCaseServant.jce'
// **********************************************************************

#ifndef __TAFCASESERVANT_H_
#define __TAFCASESERVANT_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace Test
{
    struct UserInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Test.UserInfo";
        }
        static string MD5()
        {
            return "2f4ee2019a80c199c541b97141b01bcf";
        }
        UserInfo()
        :ubQQ(0),usQQ(0),uiQQ(0),uiTest(11)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ubQQ, 0);
            _os.write(usQQ, 1);
            _os.write(uiQQ, 2);
            _os.write(uiTest, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(ubQQ, 0, true);
            _is.read(usQQ, 1, true);
            _is.read(uiQQ, 2, true);
            _is.read(uiTest, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ubQQ,"ubQQ");
            _ds.display(usQQ,"usQQ");
            _ds.display(uiQQ,"uiQQ");
            _ds.display(uiTest,"uiTest");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ubQQ, true);
            _ds.displaySimple(usQQ, true);
            _ds.displaySimple(uiQQ, true);
            _ds.displaySimple(uiTest, false);
            return _os;
        }
    public:
        taf::UInt8 ubQQ;
        taf::UInt16 usQQ;
        taf::UInt32 uiQQ;
        taf::UInt32 uiTest;
    };
    inline bool operator==(const UserInfo&l, const UserInfo&r)
    {
        return l.ubQQ == r.ubQQ && l.usQQ == r.usQQ && l.uiQQ == r.uiQQ && l.uiTest == r.uiTest;
    }
    inline bool operator!=(const UserInfo&l, const UserInfo&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class TafCaseServantPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~TafCaseServantPrxCallback(){}
        virtual void callback_test(taf::Int32 ret)
        { throw std::runtime_error("callback_test() overloading incorrect."); }
        virtual void callback_test_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_test_exception() overloading incorrect."); }

        virtual void callback_getUser(taf::Int32 ret,  const Test::UserInfo& outUser)
        { throw std::runtime_error("callback_getUser() overloading incorrect."); }
        virtual void callback_getUser_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getUser_exception() overloading incorrect."); }

        virtual void callback_testUnsigned(taf::Int32 ret, taf::UInt8 ubOutUin, taf::UInt16 usOutUin, taf::UInt32 uiOutUin)
        { throw std::runtime_error("callback_testUnsigned() overloading incorrect."); }
        virtual void callback_testUnsigned_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_testUnsigned_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<TafCaseServantPrxCallback> TafCaseServantPrxCallbackPtr;

    /* proxy for client */
    class TafCaseServantProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        taf::Int32 test(const map<string, string> &context = TAF_CONTEXT());
        void async_test(TafCaseServantPrxCallbackPtr callback,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 getUser(const Test::UserInfo & inUser,Test::UserInfo &outUser,const map<string, string> &context = TAF_CONTEXT());
        void async_getUser(TafCaseServantPrxCallbackPtr callback,const Test::UserInfo & inUser,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 testUnsigned(taf::UInt8 ubInUin,taf::UInt16 usInUin,taf::UInt32 uiInUin,taf::UInt8 &ubOutUin,taf::UInt16 &usOutUin,taf::UInt32 &uiOutUin,const map<string, string> &context = TAF_CONTEXT());
        void async_testUnsigned(TafCaseServantPrxCallbackPtr callback,taf::UInt8 ubInUin,taf::UInt16 usInUin,taf::UInt32 uiInUin,const map<string, string> &context = TAF_CONTEXT());

        TafCaseServantProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<TafCaseServantProxy> TafCaseServantPrx;

    /* servant for server */
    class TafCaseServant : public taf::Servant
    {
    public:
        virtual ~TafCaseServant(){}
        virtual taf::Int32 test(taf::JceCurrentPtr current) = 0;
        static void async_response_test(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 getUser(const Test::UserInfo & inUser,Test::UserInfo &outUser,taf::JceCurrentPtr current) = 0;
        static void async_response_getUser(taf::JceCurrentPtr current, taf::Int32 _ret, const Test::UserInfo &outUser);

        virtual taf::Int32 testUnsigned(taf::UInt8 ubInUin,taf::UInt16 usInUin,taf::UInt32 uiInUin,taf::UInt8 &ubOutUin,taf::UInt16 &usOutUin,taf::UInt32 &uiOutUin,taf::JceCurrentPtr current) = 0;
        static void async_response_testUnsigned(taf::JceCurrentPtr current, taf::Int32 _ret, taf::UInt8 ubOutUin, taf::UInt16 usOutUin, taf::UInt32 uiOutUin);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define Test_UserInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.ubQQ,b.ubQQ);jce_copy_struct(a.usQQ,b.usQQ);jce_copy_struct(a.uiQQ,b.uiQQ);jce_copy_struct(a.uiTest,b.uiTest);



#endif
