// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 2.1.5.7
// Generated from `Config.jce'
// **********************************************************************

#ifndef __CONFIG_H_
#define __CONFIG_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "servant/ServantProxy.h"
#include "servant/Servant.h"


namespace taf
{
    struct ConfigInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "taf.ConfigInfo";
        }
        static string MD5()
        {
            return "f894e779935b5e52523bdc66ba006c57";
        }
        ConfigInfo(const std::string &appname,const std::string &servername,const std::string &filename,taf::Bool bAppOnly,const std::string &host,const std::string &setdivision)
            :appname(appname),servername(servername),filename(filename),bAppOnly(bAppOnly),host(host),setdivision(setdivision)
        {
        }
        ConfigInfo()
        :appname(""),servername(""),filename(""),bAppOnly(false),host(""),setdivision("")
        {
        }
        void resetDefautlt()
        {
            appname = "";
            servername = "";
            filename = "";
            bAppOnly = false;
            host = "";
            setdivision = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(appname, 0);
            _os.write(servername, 1);
            _os.write(filename, 2);
            _os.write(bAppOnly, 3);
            _os.write(host, 4);
            _os.write(setdivision, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appname, 0, true);
            _is.read(servername, 1, true);
            _is.read(filename, 2, true);
            _is.read(bAppOnly, 3, true);
            _is.read(host, 4, false);
            _is.read(setdivision, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(appname,"appname");
            _ds.display(servername,"servername");
            _ds.display(filename,"filename");
            _ds.display(bAppOnly,"bAppOnly");
            _ds.display(host,"host");
            _ds.display(setdivision,"setdivision");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(appname, true);
            _ds.displaySimple(servername, true);
            _ds.displaySimple(filename, true);
            _ds.displaySimple(bAppOnly, true);
            _ds.displaySimple(host, true);
            _ds.displaySimple(setdivision, false);
            return _os;
        }
    public:
        std::string appname;
        std::string servername;
        std::string filename;
        taf::Bool bAppOnly;
        std::string host;
        std::string setdivision;
    };
    inline bool operator==(const ConfigInfo&l, const ConfigInfo&r)
    {
        return l.appname == r.appname && l.servername == r.servername && l.filename == r.filename && l.bAppOnly == r.bAppOnly && l.host == r.host && l.setdivision == r.setdivision;
    }
    inline bool operator!=(const ConfigInfo&l, const ConfigInfo&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class ConfigPrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~ConfigPrxCallback(){}
        virtual void callback_ListConfig(taf::Int32 ret, const vector<std::string>& vf)
        { throw std::runtime_error("callback_ListConfig() overloading incorrect."); }
        virtual void callback_ListConfig_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_ListConfig_exception() overloading incorrect."); }

        virtual void callback_loadConfig(taf::Int32 ret, const std::string& config)
        { throw std::runtime_error("callback_loadConfig() overloading incorrect."); }
        virtual void callback_loadConfig_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_loadConfig_exception() overloading incorrect."); }

        virtual void callback_loadConfigByHost(taf::Int32 ret, const std::string& config)
        { throw std::runtime_error("callback_loadConfigByHost() overloading incorrect."); }
        virtual void callback_loadConfigByHost_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_loadConfigByHost_exception() overloading incorrect."); }

        virtual void callback_checkConfig(taf::Int32 ret, const std::string& result)
        { throw std::runtime_error("callback_checkConfig() overloading incorrect."); }
        virtual void callback_checkConfig_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_checkConfig_exception() overloading incorrect."); }

        virtual void callback_ListConfigByInfo(taf::Int32 ret, const vector<std::string>& vf)
        { throw std::runtime_error("callback_ListConfigByInfo() overloading incorrect."); }
        virtual void callback_ListConfigByInfo_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_ListConfigByInfo_exception() overloading incorrect."); }

        virtual void callback_loadConfigByInfo(taf::Int32 ret, const std::string& config)
        { throw std::runtime_error("callback_loadConfigByInfo() overloading incorrect."); }
        virtual void callback_loadConfigByInfo_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_loadConfigByInfo_exception() overloading incorrect."); }

        virtual void callback_checkConfigByInfo(taf::Int32 ret, const std::string& result)
        { throw std::runtime_error("callback_checkConfigByInfo() overloading incorrect."); }
        virtual void callback_checkConfigByInfo_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_checkConfigByInfo_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<ConfigPrxCallback> ConfigPrxCallbackPtr;

    /* proxy for client */
    class ConfigProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;

        taf::Int32 ListConfig(const std::string & app,const std::string & server,vector<std::string> &vf,const map<string, string> &context = TAF_CONTEXT());
        void async_ListConfig(ConfigPrxCallbackPtr callback,const std::string & app,const std::string & server,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 loadConfig(const std::string & app,const std::string & server,const std::string & filename,std::string &config,const map<string, string> &context = TAF_CONTEXT());
        void async_loadConfig(ConfigPrxCallbackPtr callback,const std::string & app,const std::string & server,const std::string & filename,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 loadConfigByHost(const std::string & appServerName,const std::string & filename,const std::string & host,std::string &config,const map<string, string> &context = TAF_CONTEXT());
        void async_loadConfigByHost(ConfigPrxCallbackPtr callback,const std::string & appServerName,const std::string & filename,const std::string & host,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 checkConfig(const std::string & appServerName,const std::string & filename,const std::string & host,std::string &result,const map<string, string> &context = TAF_CONTEXT());
        void async_checkConfig(ConfigPrxCallbackPtr callback,const std::string & appServerName,const std::string & filename,const std::string & host,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 ListConfigByInfo(const taf::ConfigInfo & configInfo,vector<std::string> &vf,const map<string, string> &context = TAF_CONTEXT());
        void async_ListConfigByInfo(ConfigPrxCallbackPtr callback,const taf::ConfigInfo & configInfo,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 loadConfigByInfo(const taf::ConfigInfo & configInfo,std::string &config,const map<string, string> &context = TAF_CONTEXT());
        void async_loadConfigByInfo(ConfigPrxCallbackPtr callback,const taf::ConfigInfo & configInfo,const map<string, string> &context = TAF_CONTEXT());

        taf::Int32 checkConfigByInfo(const taf::ConfigInfo & configInfo,std::string &result,const map<string, string> &context = TAF_CONTEXT());
        void async_checkConfigByInfo(ConfigPrxCallbackPtr callback,const taf::ConfigInfo & configInfo,const map<string, string> &context = TAF_CONTEXT());

        ConfigProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<ConfigProxy> ConfigPrx;

    /* servant for server */
    class Config : public taf::Servant
    {
    public:
        virtual ~Config(){}
        virtual taf::Int32 ListConfig(const std::string & app,const std::string & server,vector<std::string> &vf,taf::JceCurrentPtr current) = 0;
        static void async_response_ListConfig(taf::JceCurrentPtr current, taf::Int32 _ret, const vector<std::string> &vf);

        virtual taf::Int32 loadConfig(const std::string & app,const std::string & server,const std::string & filename,std::string &config,taf::JceCurrentPtr current) = 0;
        static void async_response_loadConfig(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &config);

        virtual taf::Int32 loadConfigByHost(const std::string & appServerName,const std::string & filename,const std::string & host,std::string &config,taf::JceCurrentPtr current) = 0;
        static void async_response_loadConfigByHost(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &config);

        virtual taf::Int32 checkConfig(const std::string & appServerName,const std::string & filename,const std::string & host,std::string &result,taf::JceCurrentPtr current) = 0;
        static void async_response_checkConfig(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &result);

        virtual taf::Int32 ListConfigByInfo(const taf::ConfigInfo & configInfo,vector<std::string> &vf,taf::JceCurrentPtr current) = 0;
        static void async_response_ListConfigByInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const vector<std::string> &vf);

        virtual taf::Int32 loadConfigByInfo(const taf::ConfigInfo & configInfo,std::string &config,taf::JceCurrentPtr current) = 0;
        static void async_response_loadConfigByInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &config);

        virtual taf::Int32 checkConfigByInfo(const taf::ConfigInfo & configInfo,std::string &result,taf::JceCurrentPtr current) = 0;
        static void async_response_checkConfigByInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const std::string &result);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define taf_ConfigInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.appname,b.appname);jce_copy_struct(a.servername,b.servername);jce_copy_struct(a.filename,b.filename);jce_copy_struct(a.bAppOnly,b.bAppOnly);jce_copy_struct(a.host,b.host);jce_copy_struct(a.setdivision,b.setdivision);



#endif
