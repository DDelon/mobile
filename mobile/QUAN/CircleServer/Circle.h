// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 2.1.4.3 by WSRD Tencent.
// Generated from `Circle.jce'
// **********************************************************************

#ifndef __CIRCLE_H_
#define __CIRCLE_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "SecretBase.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "servant/TafCallbacks.h"


namespace QUAN
{
    struct CircleKey : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleKey";
        }
        static string MD5()
        {
            return "c5d29a3a3b5e33926ecd936ff3153e6b";
        }
        CircleKey(taf::Int64 id)
            :id(id)
        {
        }
        CircleKey()
        :id(0)
        {
        }
        void resetDefautlt()
        {
            id = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(id, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(id, false);
            return _os;
        }
    public:
        taf::Int64 id;
    };
    inline bool operator==(const CircleKey&l, const CircleKey&r)
    {
        return l.id == r.id;
    }
    inline bool operator!=(const CircleKey&l, const CircleKey&r)
    {
        return !(l == r);
    }

    struct CircleValue : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleValue";
        }
        static string MD5()
        {
            return "9c4b988d87248348c1045cdcd91a6bf9";
        }
        CircleValue(taf::Int32 iTimespan,const QUAN::CircleInfo &tCircleInfo)
            :iTimespan(iTimespan),tCircleInfo(tCircleInfo)
        {
        }
        CircleValue()
        :iTimespan(0)
        {
        }
        void resetDefautlt()
        {
            iTimespan = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iTimespan, 0);
            _os.write(tCircleInfo, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iTimespan, 0, false);
            _is.read(tCircleInfo, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iTimespan,"iTimespan");
            _ds.display(tCircleInfo,"tCircleInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iTimespan, true);
            _ds.displaySimple(tCircleInfo, false);
            return _os;
        }
    public:
        taf::Int32 iTimespan;
        QUAN::CircleInfo tCircleInfo;
    };
    inline bool operator==(const CircleValue&l, const CircleValue&r)
    {
        return l.iTimespan == r.iTimespan && l.tCircleInfo == r.tCircleInfo;
    }
    inline bool operator!=(const CircleValue&l, const CircleValue&r)
    {
        return !(l == r);
    }

    struct CircleLbsInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleLbsInfo";
        }
        static string MD5()
        {
            return "7b90727bbd115126d5329feef6715319";
        }
        CircleLbsInfo(taf::Int64 lCircleId,const QUAN::CircleLocation &tLocation)
            :lCircleId(lCircleId),tLocation(tLocation)
        {
        }
        CircleLbsInfo()
        :lCircleId(0)
        {
        }
        void resetDefautlt()
        {
            lCircleId = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(lCircleId, 0);
            _os.write(tLocation, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(lCircleId, 0, false);
            _is.read(tLocation, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(lCircleId,"lCircleId");
            _ds.display(tLocation,"tLocation");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(lCircleId, true);
            _ds.displaySimple(tLocation, false);
            return _os;
        }
    public:
        taf::Int64 lCircleId;
        QUAN::CircleLocation tLocation;
    };
    inline bool operator==(const CircleLbsInfo&l, const CircleLbsInfo&r)
    {
        return l.lCircleId == r.lCircleId && l.tLocation == r.tLocation;
    }
    inline bool operator!=(const CircleLbsInfo&l, const CircleLbsInfo&r)
    {
        return !(l == r);
    }

    struct CircleLbsValue : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleLbsValue";
        }
        static string MD5()
        {
            return "951b5367a4c89c0f87f771c628982b0d";
        }
        CircleLbsValue(taf::Int32 iTimespan,const vector<QUAN::CircleLbsInfo> &vCircleLbsInfo)
            :iTimespan(iTimespan),vCircleLbsInfo(vCircleLbsInfo)
        {
        }
        CircleLbsValue()
        :iTimespan(0)
        {
        }
        void resetDefautlt()
        {
            iTimespan = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iTimespan, 0);
            _os.write(vCircleLbsInfo, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iTimespan, 0, false);
            _is.read(vCircleLbsInfo, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iTimespan,"iTimespan");
            _ds.display(vCircleLbsInfo,"vCircleLbsInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iTimespan, true);
            _ds.displaySimple(vCircleLbsInfo, false);
            return _os;
        }
    public:
        taf::Int32 iTimespan;
        vector<QUAN::CircleLbsInfo> vCircleLbsInfo;
    };
    inline bool operator==(const CircleLbsValue&l, const CircleLbsValue&r)
    {
        return l.iTimespan == r.iTimespan && l.vCircleLbsInfo == r.vCircleLbsInfo;
    }
    inline bool operator!=(const CircleLbsValue&l, const CircleLbsValue&r)
    {
        return !(l == r);
    }

    struct CircleUserValue : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleUserValue";
        }
        static string MD5()
        {
            return "b2308e13735f62d02d86cd65fcb5b3bf";
        }
        CircleUserValue(taf::Int32 iTimespan,const vector<taf::Int64> &vConcern,const vector<taf::Int64> &vAccessable)
            :iTimespan(iTimespan),vConcern(vConcern),vAccessable(vAccessable)
        {
        }
        CircleUserValue()
        :iTimespan(0)
        {
        }
        void resetDefautlt()
        {
            iTimespan = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iTimespan, 0);
            _os.write(vConcern, 1);
            _os.write(vAccessable, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iTimespan, 0, false);
            _is.read(vConcern, 1, false);
            _is.read(vAccessable, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iTimespan,"iTimespan");
            _ds.display(vConcern,"vConcern");
            _ds.display(vAccessable,"vAccessable");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iTimespan, true);
            _ds.displaySimple(vConcern, true);
            _ds.displaySimple(vAccessable, false);
            return _os;
        }
    public:
        taf::Int32 iTimespan;
        vector<taf::Int64> vConcern;
        vector<taf::Int64> vAccessable;
    };
    inline bool operator==(const CircleUserValue&l, const CircleUserValue&r)
    {
        return l.iTimespan == r.iTimespan && l.vConcern == r.vConcern && l.vAccessable == r.vAccessable;
    }
    inline bool operator!=(const CircleUserValue&l, const CircleUserValue&r)
    {
        return !(l == r);
    }

    struct CircleUnlockKey : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleUnlockKey";
        }
        static string MD5()
        {
            return "a0f7f1c70b82271b1f084e61faf77494";
        }
        CircleUnlockKey(taf::Int64 lUId,taf::Int64 lCircleId)
            :lUId(lUId),lCircleId(lCircleId)
        {
        }
        CircleUnlockKey()
        :lUId(0),lCircleId(0)
        {
        }
        void resetDefautlt()
        {
            lUId = 0;
            lCircleId = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(lUId, 0);
            _os.write(lCircleId, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(lUId, 0, false);
            _is.read(lCircleId, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(lUId,"lUId");
            _ds.display(lCircleId,"lCircleId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(lUId, true);
            _ds.displaySimple(lCircleId, false);
            return _os;
        }
    public:
        taf::Int64 lUId;
        taf::Int64 lCircleId;
    };
    inline bool operator==(const CircleUnlockKey&l, const CircleUnlockKey&r)
    {
        return l.lUId == r.lUId && l.lCircleId == r.lCircleId;
    }
    inline bool operator!=(const CircleUnlockKey&l, const CircleUnlockKey&r)
    {
        return !(l == r);
    }

    struct CircleUnlockValue : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleUnlockValue";
        }
        static string MD5()
        {
            return "feec12de7b13d3c49a37abb722ac4db4";
        }
        CircleUnlockValue(taf::Int32 iTimespan,taf::Int32 iLockNum)
            :iTimespan(iTimespan),iLockNum(iLockNum)
        {
        }
        CircleUnlockValue()
        :iTimespan(0),iLockNum(0)
        {
        }
        void resetDefautlt()
        {
            iTimespan = 0;
            iLockNum = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iTimespan, 0);
            _os.write(iLockNum, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iTimespan, 0, false);
            _is.read(iLockNum, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iTimespan,"iTimespan");
            _ds.display(iLockNum,"iLockNum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iTimespan, true);
            _ds.displaySimple(iLockNum, false);
            return _os;
        }
    public:
        taf::Int32 iTimespan;
        taf::Int32 iLockNum;
    };
    inline bool operator==(const CircleUnlockValue&l, const CircleUnlockValue&r)
    {
        return l.iTimespan == r.iTimespan && l.iLockNum == r.iLockNum;
    }
    inline bool operator!=(const CircleUnlockValue&l, const CircleUnlockValue&r)
    {
        return !(l == r);
    }

    struct CircleLocationValue : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleLocationValue";
        }
        static string MD5()
        {
            return "83ff615cfa7ef6b2058f06571e3af1a8";
        }
        CircleLocationValue(taf::Int32 iTimespan,const vector<QUAN::CircleLocation> &vLocation)
            :iTimespan(iTimespan),vLocation(vLocation)
        {
        }
        CircleLocationValue()
        :iTimespan(0)
        {
        }
        void resetDefautlt()
        {
            iTimespan = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iTimespan, 0);
            _os.write(vLocation, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iTimespan, 0, false);
            _is.read(vLocation, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iTimespan,"iTimespan");
            _ds.display(vLocation,"vLocation");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iTimespan, true);
            _ds.displaySimple(vLocation, false);
            return _os;
        }
    public:
        taf::Int32 iTimespan;
        vector<QUAN::CircleLocation> vLocation;
    };
    inline bool operator==(const CircleLocationValue&l, const CircleLocationValue&r)
    {
        return l.iTimespan == r.iTimespan && l.vLocation == r.vLocation;
    }
    inline bool operator!=(const CircleLocationValue&l, const CircleLocationValue&r)
    {
        return !(l == r);
    }

    struct CircleIdList : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QUAN.CircleIdList";
        }
        static string MD5()
        {
            return "67803168b2c61e33943958e9080ca892";
        }
        CircleIdList(const vector<taf::Int64> &vCircleId)
            :vCircleId(vCircleId)
        {
        }
        CircleIdList()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vCircleId, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vCircleId, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vCircleId,"vCircleId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vCircleId, false);
            return _os;
        }
    public:
        vector<taf::Int64> vCircleId;
    };
    inline bool operator==(const CircleIdList&l, const CircleIdList&r)
    {
        return l.vCircleId == r.vCircleId;
    }
    inline bool operator!=(const CircleIdList&l, const CircleIdList&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class CirclePrxCallback: public taf::ServantProxyCallback
    {
    public:
        virtual ~CirclePrxCallback(){}
        virtual void callback_createCircle(taf::Int32 ret, const QUAN::CreateCircleRsp& tRsp)
        { throw std::runtime_error("callback_createCircle() overloading incorrect."); }
        virtual void callback_createCircle_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_createCircle_exception() overloading incorrect."); }

        virtual void callback_createCircleByAdmin(taf::Int32 ret, const QUAN::CreateCircleRsp& tRsp)
        { throw std::runtime_error("callback_createCircleByAdmin() overloading incorrect."); }
        virtual void callback_createCircleByAdmin_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_createCircleByAdmin_exception() overloading incorrect."); }

        virtual void callback_searchCircle(taf::Int32 ret, const QUAN::SearchCircleRsp& tRsp)
        { throw std::runtime_error("callback_searchCircle() overloading incorrect."); }
        virtual void callback_searchCircle_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_searchCircle_exception() overloading incorrect."); }

        virtual void callback_getCircle(taf::Int32 ret, const QUAN::GetCircleRsp& tRsp)
        { throw std::runtime_error("callback_getCircle() overloading incorrect."); }
        virtual void callback_getCircle_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getCircle_exception() overloading incorrect."); }

        virtual void callback_getCircleInfo(taf::Int32 ret, const QUAN::CircleInfo& tCircleInfo)
        { throw std::runtime_error("callback_getCircleInfo() overloading incorrect."); }
        virtual void callback_getCircleInfo_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_getCircleInfo_exception() overloading incorrect."); }

        virtual void callback_setCircleConcern(taf::Int32 ret)
        { throw std::runtime_error("callback_setCircleConcern() overloading incorrect."); }
        virtual void callback_setCircleConcern_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_setCircleConcern_exception() overloading incorrect."); }

        virtual void callback_postInCircle(taf::Int32 ret)
        { throw std::runtime_error("callback_postInCircle() overloading incorrect."); }
        virtual void callback_postInCircle_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_postInCircle_exception() overloading incorrect."); }

        virtual void callback_auditCircle(taf::Int32 ret)
        { throw std::runtime_error("callback_auditCircle() overloading incorrect."); }
        virtual void callback_auditCircle_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_auditCircle_exception() overloading incorrect."); }

        virtual void callback_recommCircle(taf::Int32 ret)
        { throw std::runtime_error("callback_recommCircle() overloading incorrect."); }
        virtual void callback_recommCircle_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_recommCircle_exception() overloading incorrect."); }

        virtual void callback_clearCircleCache(taf::Int32 ret)
        { throw std::runtime_error("callback_clearCircleCache() overloading incorrect."); }
        virtual void callback_clearCircleCache_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_clearCircleCache_exception() overloading incorrect."); }

        virtual void callback_clearLbsCache(taf::Int32 ret)
        { throw std::runtime_error("callback_clearLbsCache() overloading incorrect."); }
        virtual void callback_clearLbsCache_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_clearLbsCache_exception() overloading incorrect."); }

        virtual void callback_addCircleLocation(taf::Int32 ret)
        { throw std::runtime_error("callback_addCircleLocation() overloading incorrect."); }
        virtual void callback_addCircleLocation_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_addCircleLocation_exception() overloading incorrect."); }

        virtual void callback_modifyCircleLocation(taf::Int32 ret)
        { throw std::runtime_error("callback_modifyCircleLocation() overloading incorrect."); }
        virtual void callback_modifyCircleLocation_exception(taf::Int32 ret)
        { throw std::runtime_error("callback_modifyCircleLocation_exception() overloading incorrect."); }

    public:
        int onDispatch(taf::ReqMessagePtr msg);
    };
    typedef taf::TC_AutoPtr<CirclePrxCallback> CirclePrxCallbackPtr;

    /* callback of lambda_async support proxy for client */
    template<typename ...Args>
    class CirclePrxCallbackImp:public CirclePrxCallback,public tafAsync::TafCallback<Args...>
    {
    public:
        virtual void callback_createCircle(taf::Int32 ret, const QUAN::CreateCircleRsp& tRsp)
        { tafAsync::TafCallback<Args...>::doCalls(ret,tRsp);}
        virtual void callback_createCircle_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_createCircleByAdmin(taf::Int32 ret, const QUAN::CreateCircleRsp& tRsp)
        { tafAsync::TafCallback<Args...>::doCalls(ret,tRsp);}
        virtual void callback_createCircleByAdmin_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_searchCircle(taf::Int32 ret, const QUAN::SearchCircleRsp& tRsp)
        { tafAsync::TafCallback<Args...>::doCalls(ret,tRsp);}
        virtual void callback_searchCircle_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_getCircle(taf::Int32 ret, const QUAN::GetCircleRsp& tRsp)
        { tafAsync::TafCallback<Args...>::doCalls(ret,tRsp);}
        virtual void callback_getCircle_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_getCircleInfo(taf::Int32 ret, const QUAN::CircleInfo& tCircleInfo)
        { tafAsync::TafCallback<Args...>::doCalls(ret,tCircleInfo);}
        virtual void callback_getCircleInfo_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_setCircleConcern(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_setCircleConcern_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_postInCircle(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_postInCircle_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_auditCircle(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_auditCircle_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_recommCircle(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_recommCircle_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_clearCircleCache(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_clearCircleCache_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_clearLbsCache(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_clearLbsCache_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_addCircleLocation(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_addCircleLocation_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

        virtual void callback_modifyCircleLocation(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::doCalls(ret);}
        virtual void callback_modifyCircleLocation_exception(taf::Int32 ret)
        { tafAsync::TafCallback<Args...>::handleException(ret);}

    };
    /* proxy for client */
    class CircleProxy : public taf::ServantProxy
    {
    public:
        typedef map<string, string> TAF_CONTEXT;
        typedef CirclePrxCallbackImp<taf::Int32, const QUAN::CreateCircleRsp&> taf_createCircleCb;
        typedef CirclePrxCallbackImp<taf::Int32, const QUAN::CreateCircleRsp&> taf_createCircleByAdminCb;
        typedef CirclePrxCallbackImp<taf::Int32, const QUAN::SearchCircleRsp&> taf_searchCircleCb;
        typedef CirclePrxCallbackImp<taf::Int32, const QUAN::GetCircleRsp&> taf_getCircleCb;
        typedef CirclePrxCallbackImp<taf::Int32, const QUAN::CircleInfo&> taf_getCircleInfoCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_setCircleConcernCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_postInCircleCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_auditCircleCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_recommCircleCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_clearCircleCacheCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_clearLbsCacheCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_addCircleLocationCb;
        typedef CirclePrxCallbackImp<taf::Int32> taf_modifyCircleLocationCb;

        taf::Int32 createCircle(const QUAN::CreateCircleReq & tReq,QUAN::CreateCircleRsp &tRsp,const map<string, string> &context = TAF_CONTEXT());
        void async_createCircle(CirclePrxCallbackPtr callback,const QUAN::CreateCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_createCircleCb> async_createCircle(const QUAN::CreateCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_createCircleCb> cb=new taf_createCircleCb; async_createCircle(cb,tReq,context);return cb; }

        taf::Int32 createCircleByAdmin(const QUAN::CreateCircleReq & tReq,const vector<QUAN::CircleLocation> & vCircleLocation,QUAN::CreateCircleRsp &tRsp,const map<string, string> &context = TAF_CONTEXT());
        void async_createCircleByAdmin(CirclePrxCallbackPtr callback,const QUAN::CreateCircleReq & tReq,const vector<QUAN::CircleLocation> & vCircleLocation,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_createCircleByAdminCb> async_createCircleByAdmin(const QUAN::CreateCircleReq & tReq,const vector<QUAN::CircleLocation> & vCircleLocation,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_createCircleByAdminCb> cb=new taf_createCircleByAdminCb; async_createCircleByAdmin(cb,tReq,vCircleLocation,context);return cb; }

        taf::Int32 searchCircle(const QUAN::SearchCircleReq & tReq,QUAN::SearchCircleRsp &tRsp,const map<string, string> &context = TAF_CONTEXT());
        void async_searchCircle(CirclePrxCallbackPtr callback,const QUAN::SearchCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_searchCircleCb> async_searchCircle(const QUAN::SearchCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_searchCircleCb> cb=new taf_searchCircleCb; async_searchCircle(cb,tReq,context);return cb; }

        taf::Int32 getCircle(const QUAN::GetCircleReq & tReq,QUAN::GetCircleRsp &tRsp,const map<string, string> &context = TAF_CONTEXT());
        void async_getCircle(CirclePrxCallbackPtr callback,const QUAN::GetCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_getCircleCb> async_getCircle(const QUAN::GetCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_getCircleCb> cb=new taf_getCircleCb; async_getCircle(cb,tReq,context);return cb; }

        taf::Int32 getCircleInfo(const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,QUAN::CircleInfo &tCircleInfo,const map<string, string> &context = TAF_CONTEXT());
        void async_getCircleInfo(CirclePrxCallbackPtr callback,const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_getCircleInfoCb> async_getCircleInfo(const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_getCircleInfoCb> cb=new taf_getCircleInfoCb; async_getCircleInfo(cb,tId,lCircleId,sCoord,context);return cb; }

        taf::Int32 setCircleConcern(const QUAN::SetCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT());
        void async_setCircleConcern(CirclePrxCallbackPtr callback,const QUAN::SetCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_setCircleConcernCb> async_setCircleConcern(const QUAN::SetCircleReq & tReq,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_setCircleConcernCb> cb=new taf_setCircleConcernCb; async_setCircleConcern(cb,tReq,context);return cb; }

        taf::Int32 postInCircle(const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,taf::Bool bIsComment,const map<string, string> &context = TAF_CONTEXT());
        void async_postInCircle(CirclePrxCallbackPtr callback,const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,taf::Bool bIsComment,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_postInCircleCb> async_postInCircle(const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,taf::Bool bIsComment,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_postInCircleCb> cb=new taf_postInCircleCb; async_postInCircle(cb,tId,lCircleId,sCoord,bIsComment,context);return cb; }

        taf::Int32 auditCircle(taf::Int64 lCircleId,taf::Int32 iAuditState,const std::string & sReason,const map<string, string> &context = TAF_CONTEXT());
        void async_auditCircle(CirclePrxCallbackPtr callback,taf::Int64 lCircleId,taf::Int32 iAuditState,const std::string & sReason,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_auditCircleCb> async_auditCircle(taf::Int64 lCircleId,taf::Int32 iAuditState,const std::string & sReason,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_auditCircleCb> cb=new taf_auditCircleCb; async_auditCircle(cb,lCircleId,iAuditState,sReason,context);return cb; }

        taf::Int32 recommCircle(taf::Int64 lCircleId,taf::Int32 iRecommValue,const map<string, string> &context = TAF_CONTEXT());
        void async_recommCircle(CirclePrxCallbackPtr callback,taf::Int64 lCircleId,taf::Int32 iRecommValue,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_recommCircleCb> async_recommCircle(taf::Int64 lCircleId,taf::Int32 iRecommValue,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_recommCircleCb> cb=new taf_recommCircleCb; async_recommCircle(cb,lCircleId,iRecommValue,context);return cb; }

        taf::Int32 clearCircleCache(taf::Int64 lCircleId,const map<string, string> &context = TAF_CONTEXT());
        void async_clearCircleCache(CirclePrxCallbackPtr callback,taf::Int64 lCircleId,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_clearCircleCacheCb> async_clearCircleCache(taf::Int64 lCircleId,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_clearCircleCacheCb> cb=new taf_clearCircleCacheCb; async_clearCircleCache(cb,lCircleId,context);return cb; }

        taf::Int32 clearLbsCache(const std::string & sCoord,const map<string, string> &context = TAF_CONTEXT());
        void async_clearLbsCache(CirclePrxCallbackPtr callback,const std::string & sCoord,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_clearLbsCacheCb> async_clearLbsCache(const std::string & sCoord,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_clearLbsCacheCb> cb=new taf_clearLbsCacheCb; async_clearLbsCache(cb,sCoord,context);return cb; }

        taf::Int32 addCircleLocation(taf::Int64 lCircleId,const QUAN::CircleLocation & tCircleLocation,const map<string, string> &context = TAF_CONTEXT());
        void async_addCircleLocation(CirclePrxCallbackPtr callback,taf::Int64 lCircleId,const QUAN::CircleLocation & tCircleLocation,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_addCircleLocationCb> async_addCircleLocation(taf::Int64 lCircleId,const QUAN::CircleLocation & tCircleLocation,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_addCircleLocationCb> cb=new taf_addCircleLocationCb; async_addCircleLocation(cb,lCircleId,tCircleLocation,context);return cb; }

        taf::Int32 modifyCircleLocation(taf::Int64 lCircleLocationId,const QUAN::CircleLocation & tCircleLocation,const map<string, string> &context = TAF_CONTEXT());
        void async_modifyCircleLocation(CirclePrxCallbackPtr callback,taf::Int64 lCircleLocationId,const QUAN::CircleLocation & tCircleLocation,const map<string, string> &context = TAF_CONTEXT());

        tafAsync::AutoRef<taf_modifyCircleLocationCb> async_modifyCircleLocation(taf::Int64 lCircleLocationId,const QUAN::CircleLocation & tCircleLocation,const map<string, string> &context = TAF_CONTEXT())
        { TC_AutoPtr<taf_modifyCircleLocationCb> cb=new taf_modifyCircleLocationCb; async_modifyCircleLocation(cb,lCircleLocationId,tCircleLocation,context);return cb; }

        CircleProxy* taf_hash(int64_t key);
    };
    typedef taf::TC_AutoPtr<CircleProxy> CirclePrx;

    /* servant for server */
    class Circle : public taf::Servant
    {
    public:
        virtual ~Circle(){}
        virtual taf::Int32 createCircle(const QUAN::CreateCircleReq & tReq,QUAN::CreateCircleRsp &tRsp,taf::JceCurrentPtr current) = 0;
        static void async_response_createCircle(taf::JceCurrentPtr current, taf::Int32 _ret, const QUAN::CreateCircleRsp &tRsp);

        virtual taf::Int32 createCircleByAdmin(const QUAN::CreateCircleReq & tReq,const vector<QUAN::CircleLocation> & vCircleLocation,QUAN::CreateCircleRsp &tRsp,taf::JceCurrentPtr current) = 0;
        static void async_response_createCircleByAdmin(taf::JceCurrentPtr current, taf::Int32 _ret, const QUAN::CreateCircleRsp &tRsp);

        virtual taf::Int32 searchCircle(const QUAN::SearchCircleReq & tReq,QUAN::SearchCircleRsp &tRsp,taf::JceCurrentPtr current) = 0;
        static void async_response_searchCircle(taf::JceCurrentPtr current, taf::Int32 _ret, const QUAN::SearchCircleRsp &tRsp);

        virtual taf::Int32 getCircle(const QUAN::GetCircleReq & tReq,QUAN::GetCircleRsp &tRsp,taf::JceCurrentPtr current) = 0;
        static void async_response_getCircle(taf::JceCurrentPtr current, taf::Int32 _ret, const QUAN::GetCircleRsp &tRsp);

        virtual taf::Int32 getCircleInfo(const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,QUAN::CircleInfo &tCircleInfo,taf::JceCurrentPtr current) = 0;
        static void async_response_getCircleInfo(taf::JceCurrentPtr current, taf::Int32 _ret, const QUAN::CircleInfo &tCircleInfo);

        virtual taf::Int32 setCircleConcern(const QUAN::SetCircleReq & tReq,taf::JceCurrentPtr current) = 0;
        static void async_response_setCircleConcern(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 postInCircle(const QUAN::UserId & tId,taf::Int64 lCircleId,const std::string & sCoord,taf::Bool bIsComment,taf::JceCurrentPtr current) = 0;
        static void async_response_postInCircle(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 auditCircle(taf::Int64 lCircleId,taf::Int32 iAuditState,const std::string & sReason,taf::JceCurrentPtr current) = 0;
        static void async_response_auditCircle(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 recommCircle(taf::Int64 lCircleId,taf::Int32 iRecommValue,taf::JceCurrentPtr current) = 0;
        static void async_response_recommCircle(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 clearCircleCache(taf::Int64 lCircleId,taf::JceCurrentPtr current) = 0;
        static void async_response_clearCircleCache(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 clearLbsCache(const std::string & sCoord,taf::JceCurrentPtr current) = 0;
        static void async_response_clearLbsCache(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 addCircleLocation(taf::Int64 lCircleId,const QUAN::CircleLocation & tCircleLocation,taf::JceCurrentPtr current) = 0;
        static void async_response_addCircleLocation(taf::JceCurrentPtr current, taf::Int32 _ret);

        virtual taf::Int32 modifyCircleLocation(taf::Int64 lCircleLocationId,const QUAN::CircleLocation & tCircleLocation,taf::JceCurrentPtr current) = 0;
        static void async_response_modifyCircleLocation(taf::JceCurrentPtr current, taf::Int32 _ret);

    public:
        int onDispatch(taf::JceCurrentPtr _current, vector<char> &_sResponseBuffer);
    };


}

#define QUAN_CircleKey_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.id,b.id);

#define QUAN_CircleValue_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iTimespan,b.iTimespan);jce_copy_struct(a.tCircleInfo,b.tCircleInfo);

#define QUAN_CircleLbsInfo_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.lCircleId,b.lCircleId);jce_copy_struct(a.tLocation,b.tLocation);

#define QUAN_CircleLbsValue_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iTimespan,b.iTimespan);jce_copy_struct(a.vCircleLbsInfo,b.vCircleLbsInfo);

#define QUAN_CircleUserValue_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iTimespan,b.iTimespan);jce_copy_struct(a.vConcern,b.vConcern);jce_copy_struct(a.vAccessable,b.vAccessable);

#define QUAN_CircleUnlockKey_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.lUId,b.lUId);jce_copy_struct(a.lCircleId,b.lCircleId);

#define QUAN_CircleUnlockValue_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iTimespan,b.iTimespan);jce_copy_struct(a.iLockNum,b.iLockNum);

#define QUAN_CircleLocationValue_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.iTimespan,b.iTimespan);jce_copy_struct(a.vLocation,b.vLocation);

#define QUAN_CircleIdList_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.vCircleId,b.vCircleId);



#include "Circle.hpp"
#endif
